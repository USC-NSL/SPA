\section{Concept}
\label{sec:concept}

\begin{easylist}[itemize]
	& Framework
	&& The SPA framework uses symbolic execution with domain knowledge of how protocol implementations typically work.
	&&& Assumption that protocols operate in an event-driven FSM like fashion.
	&&& API inputs and messages have handler functions that process, validate and act upon them.
	&&& Handlers take inputs (user parameters, messages) and initial state.
	&&& Handlers process and validate the data and assert its (in)validity.
	&&& Handlers can generate outputs (messages, callback parameters) and modify state.
	&&& Typical scenario: User Input $\rightarrow$ API Handler $\rightarrow$ Sender Message Output $\rightarrow$ Receiver Message Input $\rightarrow$ Message Handler $\rightarrow$ Receiver Response Message Output $\rightarrow$ (...)
	&& Conceptually, what SPA does can be compared to using symbolic execution to extract FSM edges.
	&&& The symbolic execution starts at the API and message handlers and analyzes the program as it processes/validates those inputs, generates new outputs, and progresses to new states.
	&&& Symbolic execution gives us paths with:
	&&&& Path constraints: encode preconditions for state and inputs for the FSM edge.
	&&&& Symbolic state: encodes outputs and final state.
	&& Challenges: holding the complete and detailed representation of a program's FSM is intractable. Furthermore, symbolic execution is known to be exponentially complex in program size.
	&&& SPA can be seen as a way of getting comparatively manageable slices of the FSM.
	&&&& \eg Edges leaving/reaching a specific state.
	&&& Symbolic paths defined by constraints rather than concrete values naturally form meta-edges, encoding many state transitions in a compact representation.
	&&& Many domain specific optimizations guide the symbolic execution towards relevant results faster, allowing meaningful data to be produced earlier and progressively.
	&&&& More details in the implementation section.

	& Manipulation Attack finder
	&& Briefly define manipulation attack and refer MAX paper again.
	&& Conceptually the problem is defined as the slice of a gullible implementation's FSM that reaches the set of states defined as interesting.
	&& Find the complete set of preconditions that lead an interesting statement.
	&& Model the attacker by modifying an incoming packet to meet the desired conditions.
	&& Measure the resulting increase in utility to the attacker.

	& Message interoperability analyzer.
	&& Conceptually based on the set difference of the slices of the FSMs from two implementations.
	&& For arbitrary API inputs and starting from an initial state, find all messages that can be generated by the sender.
	&& For arbitrary message inputs and also starting from an initial state, find all messages that lead to states declared as valid on the receiver.
	&& Perform the set difference and find the set of message that the sender can send but that the receiver considers invalid.
	&& Find the corresponding set of API inputs that generate these messages and generate meaningful examples as test-cases for the user.

	& Transaction interoperability analyzer.
	&& Conceptual extension of message interoperability but with state tracking.
	&& Starting from initial states on both client and server consider arbitrary API inputs at client.
	&& Find all initial messages that can be generated and all states that can be reached from there.
	&& On server, constrain message inputs to those that can be generated and likewise find all response messages and states that can be reached.
	&& For every subsequent message receiver constrain initial state to the set of states that were reached when the previous message was sent.
	&& Continue processing like such until no more messages can be exchanged or some other imposed constraint on transaction length (number of messages) is reached.
	&& Whenever an invalid state is reached find the set of initial inputs that lead to it and output meaningful examples as test-cases for the user.

	& Compact FSM extractor
	&& Conceptual extension of transaction interoperability but where a compact representation of the global cross-product FSM is generated for visual inspection.
	&& Outputting all states and transitions would be intractable so a new FSM is created by transforming the original to a reduced form.
	&&& Collapse states that are functionally equivalent to the user.
	&&& Typically a protocols specification will describe FSMs at a high-level. An implementation's actual state can usually be remapped into that space.
	&& User annotates program with transformation functions which take actual state variable values and map them to a new representation with a smaller number of allowed values (states).
	&& Different sets of transformations can be used to succinctly illustrate independent aspects of the system.
	&&& Elaborate with examples (some already in introduction).
	&& Create transformed FSM based on cross-product of all user transformed states.
	&& Graphically represent results.
\end{easylist}
