\section{Implementation}
\label{sec:implementation}

\begin{easylist}[itemize]
	& Framework:
	&& Implemented as an extension of KLEE / Cloud9.
	&& User annotations include:
	&&& Setting up a test harness for entry points.
	&&&& Declaring API and message handler functions.
	&&&& Declaring API input parameters and message input buffers.
	&&&& Declaring state variables and initial values.
	&&& Annotating points where a packet is being sent and the message buffer (could be automated).
	&&& Annotating checkpoints in the code where it is relevant to look at current state.
	&&&& Typically when a packet is being sent or something is asserted.
	&&& Annotate waypoints that can help direct the symbolic execution towards the checkpoints.
	&&&& Helps direct execution out of complicated scenarios.
	&&&& Give example where it helps.
	&&& User-define semantic annotations.
	&&&& Define paths that pass here as valid/invalid/interesting/\etc
	&&&& Validity modeled as reachability of these statements.
	&&&& User can choose default as valid or invalid.
	&&&& Annotations then mark positions that assert exceptions to default.
	&&&& Annotations designed as generic key/value pairs, allowing more complex semantics such as \eg multiple levels of validity.
	&& Show example annotated pseudo-code.
	&& Optimizations for scalability:
	&&& There are specific points that we want to reach in the symbolic execution
	&&&& Checkpoints/Waypoints.
	&&&& Sending messages
	&&&& Asserting validity
	&&&& \etc
	&&& The CFG is filtered to cutoff exploring paths that will certainly not reach interesting points.
	&&&& Filtration points can also be of interest, as it asserts the default validity.
	&&& KLEE was modified to allow filtering paths and prioritizing the exploration of certain paths over others, a.k.a. directed symbolic execution.
	&&& By reducing path exploration to graph search, we can use established heuristics \ie A*.
	&&&& Also tried others \eg BestFS, DFS, \etc
	&& As paths are explored output the following at checkpoints or upon path termination
	&&& Path constraints
	&&& Symbolic values of outputs and current state as a function of inputs and initial state
	&&& User-defined semantic annotations, including validity.

	& Run-time utilities
	&& This is simply an alternative library stub that can be dynamically linked to the program during concrete executions.
	&& It allows the same annotations used to declare state and input to be used to inspect and overwrite their value.

	& Manipulation Attack finder.
	&& Annotate interesting statements.
	&& Define attack model by annotating relevant state and which parts of packet can be manipulated by attacker.
	&& Run symbolic analysis and get all paths that reach interesting statements.
	&& Use run-time utility to intercept actual packets coming from honest sender.
	&& Considering immutable parts of packet and current state use solver to:
	&&& Find a path that is compatible
	&&& Get example values for mutable parts of packet, and inject into the program.
	&&& Explain how constraints are built.
	&& Measure performance for the attacker gain.

	& Message interoperability analyzer
	&& Analyzes a protocol library
	&& User must prepare test harness for both sender \& receiver.
	&&& Annotate receiver with points where message are asserted valid or invalid.
	&& Run symbolic analysis independently on both sides.
	&&& On client get paths that generate output (excludes invalid inputs).
	&&& On server get paths that assert invalid messages.
	&& Post-process paths (can be done incrementally)
	&&& Cross-compare each client-server path-pair
	&&& Use solver to:
	&&&& Connect sender output message to receiver input message.
	&&&& Find concrete example API input that leads to a message that is invalid on receiver
	&&& Output result to user.

	& The following analyses are not currently implemented but this is how we plan to do it.

	& Transaction interoperability
	&& Starts with similar annotations to message interoperability.
	&& Instead of specifying fixed initial state, make symbolic, annotate initial state.
	&& Run symbolic analysis on client/server independently.
	&& State tracking done in post-processing.
	&&& Start with initial state on both client/server. Select all initial paths from client and store all symbolic states reached and corresponding output messages generated.
	&&& Process transaction states as they are updated as a consequence of messages bouncing back and forth.
	&&& For each message interaction:
	&&&& Find paths on the receiver consistent with its most recently established state within the selected transaction (path condition ANDed with transaction state conditions are SAT, message types are the same).
	&&&& Get new states transformed according to paths and get generated response messages.
	&&& Whenever invalidity is asserted solve transaction constraints to find an example of an original input that could lead to this situation. Output to user.

	& FSM extraction
	&& Starts with similar annotations to transaction interoperability.
	&& In addition to annotating state variables for each path, annotate state transformation functions
	&&& Example: VirtualState( "VirtualStateVariable", RealStateVariable1 - RealStateVariable2 );
	&& As new states are generated, keep track of transformed states as well.
	&& Using tools like Graphviz, output all unique states identified, as well as any transitions between them.
\end{easylist}
