/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|*A list of commands useable in documentation comments                        *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

namespace {
const CommandInfo Commands[] = {
  { "a", "", 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "addtogroup", "", 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
  { "attention", "", 2, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "author", "", 3, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "authors", "", 4, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "b", "", 5, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "brief", "", 6, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "bug", "", 7, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "c", "", 8, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "callback", "", 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0 },
  { "category", "", 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0 },
  { "class", "", 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0 },
  { "code", "endcode", 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 },
  { "endcode", "", 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
  { "const", "", 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0 },
  { "constant", "", 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0 },
  { "copyright", "", 16, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "date", "", 17, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "defgroup", "", 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
  { "deprecated", "", 19, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0 },
  { "details", "", 20, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "dot", "enddot", 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 },
  { "enddot", "", 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
  { "e", "", 23, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "em", "", 24, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "enum", "", 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0 },
  { "f{", "f}", 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 },
  { "f}", "", 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
  { "f[", "f]", 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 },
  { "f]", "", 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
  { "f$", "f$", 30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 },
  { "fn", "", 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0 },
  { "function", "", 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0 },
  { "headerfile", "", 33, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
  { "htmlonly", "endhtmlonly", 34, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 },
  { "endhtmlonly", "", 35, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
  { "ingroup", "", 36, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
  { "interface", "", 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0 },
  { "invariant", "", 38, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "latexonly", "endlatexonly", 39, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 },
  { "endlatexonly", "", 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
  { "mainpage", "", 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
  { "manonly", "endmanonly", 42, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 },
  { "endmanonly", "", 43, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
  { "method", "", 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0 },
  { "msc", "endmsc", 45, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 },
  { "endmsc", "", 46, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
  { "name", "", 47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
  { "namespace", "", 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0 },
  { "note", "", 49, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "overload", "", 50, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0 },
  { "p", "", 51, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "paragraph", "", 52, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
  { "param", "", 53, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "post", "", 54, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "pre", "", 55, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "property", "", 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0 },
  { "protocol", "", 57, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0 },
  { "ref", "", 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
  { "remark", "", 59, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "remarks", "", 60, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "result", "", 61, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "return", "", 62, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "returns", "", 63, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "rtfonly", "endrtfonly", 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 },
  { "endrtfonly", "", 65, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
  { "sa", "", 66, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "section", "", 67, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
  { "see", "", 68, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "short", "", 69, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "since", "", 70, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "struct", "", 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0 },
  { "subpage", "", 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
  { "subsection", "", 73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
  { "subsubsection", "", 74, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
  { "template", "", 75, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0 },
  { "templatefield", "", 76, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "todo", "", 77, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "tparam", "", 78, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "typedef", "", 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0 },
  { "union", "", 80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0 },
  { "var", "", 81, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0 },
  { "verbatim", "endverbatim", 82, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 },
  { "endverbatim", "", 83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
  { "version", "", 84, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "warning", "", 85, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "weakgroup", "", 86, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
  { "xmlonly", "endxmlonly", 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 },
  { "endxmlonly", "", 88, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 }
};
} // unnamed namespace

const CommandInfo *CommandTraits::getBuiltinCommandInfo(
                                         StringRef Name) {
  switch (Name.size()) {
  default: break;
  case 1:	 // 5 strings to match.
    switch (Name[0]) {
    default: break;
    case 'a':	 // 1 string to match.
      return &Commands[0];	 // "a"
    case 'b':	 // 1 string to match.
      return &Commands[5];	 // "b"
    case 'c':	 // 1 string to match.
      return &Commands[8];	 // "c"
    case 'e':	 // 1 string to match.
      return &Commands[23];	 // "e"
    case 'p':	 // 1 string to match.
      return &Commands[51];	 // "p"
    }
    break;
  case 2:	 // 8 strings to match.
    switch (Name[0]) {
    default: break;
    case 'e':	 // 1 string to match.
      if (Name[1] != 'm')
        break;
      return &Commands[24];	 // "em"
    case 'f':	 // 6 strings to match.
      switch (Name[1]) {
      default: break;
      case '$':	 // 1 string to match.
        return &Commands[30];	 // "f$"
      case '[':	 // 1 string to match.
        return &Commands[28];	 // "f["
      case ']':	 // 1 string to match.
        return &Commands[29];	 // "f]"
      case 'n':	 // 1 string to match.
        return &Commands[31];	 // "fn"
      case '{':	 // 1 string to match.
        return &Commands[26];	 // "f{"
      case '}':	 // 1 string to match.
        return &Commands[27];	 // "f}"
      }
      break;
    case 's':	 // 1 string to match.
      if (Name[1] != 'a')
        break;
      return &Commands[66];	 // "sa"
    }
    break;
  case 3:	 // 7 strings to match.
    switch (Name[0]) {
    default: break;
    case 'b':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ug", 2))
        break;
      return &Commands[7];	 // "bug"
    case 'd':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ot", 2))
        break;
      return &Commands[21];	 // "dot"
    case 'm':	 // 1 string to match.
      if (memcmp(Name.data()+1, "sc", 2))
        break;
      return &Commands[45];	 // "msc"
    case 'p':	 // 1 string to match.
      if (memcmp(Name.data()+1, "re", 2))
        break;
      return &Commands[55];	 // "pre"
    case 'r':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ef", 2))
        break;
      return &Commands[58];	 // "ref"
    case 's':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ee", 2))
        break;
      return &Commands[68];	 // "see"
    case 'v':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ar", 2))
        break;
      return &Commands[81];	 // "var"
    }
    break;
  case 4:	 // 7 strings to match.
    switch (Name[0]) {
    default: break;
    case 'c':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ode", 3))
        break;
      return &Commands[12];	 // "code"
    case 'd':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ate", 3))
        break;
      return &Commands[17];	 // "date"
    case 'e':	 // 1 string to match.
      if (memcmp(Name.data()+1, "num", 3))
        break;
      return &Commands[25];	 // "enum"
    case 'n':	 // 2 strings to match.
      switch (Name[1]) {
      default: break;
      case 'a':	 // 1 string to match.
        if (memcmp(Name.data()+2, "me", 2))
          break;
        return &Commands[47];	 // "name"
      case 'o':	 // 1 string to match.
        if (memcmp(Name.data()+2, "te", 2))
          break;
        return &Commands[49];	 // "note"
      }
      break;
    case 'p':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ost", 3))
        break;
      return &Commands[54];	 // "post"
    case 't':	 // 1 string to match.
      if (memcmp(Name.data()+1, "odo", 3))
        break;
      return &Commands[77];	 // "todo"
    }
    break;
  case 5:	 // 7 strings to match.
    switch (Name[0]) {
    default: break;
    case 'b':	 // 1 string to match.
      if (memcmp(Name.data()+1, "rief", 4))
        break;
      return &Commands[6];	 // "brief"
    case 'c':	 // 2 strings to match.
      switch (Name[1]) {
      default: break;
      case 'l':	 // 1 string to match.
        if (memcmp(Name.data()+2, "ass", 3))
          break;
        return &Commands[11];	 // "class"
      case 'o':	 // 1 string to match.
        if (memcmp(Name.data()+2, "nst", 3))
          break;
        return &Commands[14];	 // "const"
      }
      break;
    case 'p':	 // 1 string to match.
      if (memcmp(Name.data()+1, "aram", 4))
        break;
      return &Commands[53];	 // "param"
    case 's':	 // 2 strings to match.
      switch (Name[1]) {
      default: break;
      case 'h':	 // 1 string to match.
        if (memcmp(Name.data()+2, "ort", 3))
          break;
        return &Commands[69];	 // "short"
      case 'i':	 // 1 string to match.
        if (memcmp(Name.data()+2, "nce", 3))
          break;
        return &Commands[70];	 // "since"
      }
      break;
    case 'u':	 // 1 string to match.
      if (memcmp(Name.data()+1, "nion", 4))
        break;
      return &Commands[80];	 // "union"
    }
    break;
  case 6:	 // 9 strings to match.
    switch (Name[0]) {
    default: break;
    case 'a':	 // 1 string to match.
      if (memcmp(Name.data()+1, "uthor", 5))
        break;
      return &Commands[3];	 // "author"
    case 'e':	 // 2 strings to match.
      if (memcmp(Name.data()+1, "nd", 2))
        break;
      switch (Name[3]) {
      default: break;
      case 'd':	 // 1 string to match.
        if (memcmp(Name.data()+4, "ot", 2))
          break;
        return &Commands[22];	 // "enddot"
      case 'm':	 // 1 string to match.
        if (memcmp(Name.data()+4, "sc", 2))
          break;
        return &Commands[46];	 // "endmsc"
      }
      break;
    case 'm':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ethod", 5))
        break;
      return &Commands[44];	 // "method"
    case 'r':	 // 3 strings to match.
      if (Name[1] != 'e')
        break;
      switch (Name[2]) {
      default: break;
      case 'm':	 // 1 string to match.
        if (memcmp(Name.data()+3, "ark", 3))
          break;
        return &Commands[59];	 // "remark"
      case 's':	 // 1 string to match.
        if (memcmp(Name.data()+3, "ult", 3))
          break;
        return &Commands[61];	 // "result"
      case 't':	 // 1 string to match.
        if (memcmp(Name.data()+3, "urn", 3))
          break;
        return &Commands[62];	 // "return"
      }
      break;
    case 's':	 // 1 string to match.
      if (memcmp(Name.data()+1, "truct", 5))
        break;
      return &Commands[71];	 // "struct"
    case 't':	 // 1 string to match.
      if (memcmp(Name.data()+1, "param", 5))
        break;
      return &Commands[78];	 // "tparam"
    }
    break;
  case 7:	 // 14 strings to match.
    switch (Name[0]) {
    default: break;
    case 'a':	 // 1 string to match.
      if (memcmp(Name.data()+1, "uthors", 6))
        break;
      return &Commands[4];	 // "authors"
    case 'd':	 // 1 string to match.
      if (memcmp(Name.data()+1, "etails", 6))
        break;
      return &Commands[20];	 // "details"
    case 'e':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ndcode", 6))
        break;
      return &Commands[13];	 // "endcode"
    case 'i':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ngroup", 6))
        break;
      return &Commands[36];	 // "ingroup"
    case 'm':	 // 1 string to match.
      if (memcmp(Name.data()+1, "anonly", 6))
        break;
      return &Commands[42];	 // "manonly"
    case 'r':	 // 3 strings to match.
      switch (Name[1]) {
      default: break;
      case 'e':	 // 2 strings to match.
        switch (Name[2]) {
        default: break;
        case 'm':	 // 1 string to match.
          if (memcmp(Name.data()+3, "arks", 4))
            break;
          return &Commands[60];	 // "remarks"
        case 't':	 // 1 string to match.
          if (memcmp(Name.data()+3, "urns", 4))
            break;
          return &Commands[63];	 // "returns"
        }
        break;
      case 't':	 // 1 string to match.
        if (memcmp(Name.data()+2, "fonly", 5))
          break;
        return &Commands[64];	 // "rtfonly"
      }
      break;
    case 's':	 // 2 strings to match.
      switch (Name[1]) {
      default: break;
      case 'e':	 // 1 string to match.
        if (memcmp(Name.data()+2, "ction", 5))
          break;
        return &Commands[67];	 // "section"
      case 'u':	 // 1 string to match.
        if (memcmp(Name.data()+2, "bpage", 5))
          break;
        return &Commands[72];	 // "subpage"
      }
      break;
    case 't':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ypedef", 6))
        break;
      return &Commands[79];	 // "typedef"
    case 'v':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ersion", 6))
        break;
      return &Commands[84];	 // "version"
    case 'w':	 // 1 string to match.
      if (memcmp(Name.data()+1, "arning", 6))
        break;
      return &Commands[85];	 // "warning"
    case 'x':	 // 1 string to match.
      if (memcmp(Name.data()+1, "mlonly", 6))
        break;
      return &Commands[87];	 // "xmlonly"
    }
    break;
  case 8:	 // 12 strings to match.
    switch (Name[0]) {
    default: break;
    case 'c':	 // 3 strings to match.
      switch (Name[1]) {
      default: break;
      case 'a':	 // 2 strings to match.
        switch (Name[2]) {
        default: break;
        case 'l':	 // 1 string to match.
          if (memcmp(Name.data()+3, "lback", 5))
            break;
          return &Commands[9];	 // "callback"
        case 't':	 // 1 string to match.
          if (memcmp(Name.data()+3, "egory", 5))
            break;
          return &Commands[10];	 // "category"
        }
        break;
      case 'o':	 // 1 string to match.
        if (memcmp(Name.data()+2, "nstant", 6))
          break;
        return &Commands[15];	 // "constant"
      }
      break;
    case 'd':	 // 1 string to match.
      if (memcmp(Name.data()+1, "efgroup", 7))
        break;
      return &Commands[18];	 // "defgroup"
    case 'f':	 // 1 string to match.
      if (memcmp(Name.data()+1, "unction", 7))
        break;
      return &Commands[32];	 // "function"
    case 'h':	 // 1 string to match.
      if (memcmp(Name.data()+1, "tmlonly", 7))
        break;
      return &Commands[34];	 // "htmlonly"
    case 'm':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ainpage", 7))
        break;
      return &Commands[41];	 // "mainpage"
    case 'o':	 // 1 string to match.
      if (memcmp(Name.data()+1, "verload", 7))
        break;
      return &Commands[50];	 // "overload"
    case 'p':	 // 2 strings to match.
      if (memcmp(Name.data()+1, "ro", 2))
        break;
      switch (Name[3]) {
      default: break;
      case 'p':	 // 1 string to match.
        if (memcmp(Name.data()+4, "erty", 4))
          break;
        return &Commands[56];	 // "property"
      case 't':	 // 1 string to match.
        if (memcmp(Name.data()+4, "ocol", 4))
          break;
        return &Commands[57];	 // "protocol"
      }
      break;
    case 't':	 // 1 string to match.
      if (memcmp(Name.data()+1, "emplate", 7))
        break;
      return &Commands[75];	 // "template"
    case 'v':	 // 1 string to match.
      if (memcmp(Name.data()+1, "erbatim", 7))
        break;
      return &Commands[82];	 // "verbatim"
    }
    break;
  case 9:	 // 8 strings to match.
    switch (Name[0]) {
    default: break;
    case 'a':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ttention", 8))
        break;
      return &Commands[2];	 // "attention"
    case 'c':	 // 1 string to match.
      if (memcmp(Name.data()+1, "opyright", 8))
        break;
      return &Commands[16];	 // "copyright"
    case 'i':	 // 2 strings to match.
      if (Name[1] != 'n')
        break;
      switch (Name[2]) {
      default: break;
      case 't':	 // 1 string to match.
        if (memcmp(Name.data()+3, "erface", 6))
          break;
        return &Commands[37];	 // "interface"
      case 'v':	 // 1 string to match.
        if (memcmp(Name.data()+3, "ariant", 6))
          break;
        return &Commands[38];	 // "invariant"
      }
      break;
    case 'l':	 // 1 string to match.
      if (memcmp(Name.data()+1, "atexonly", 8))
        break;
      return &Commands[39];	 // "latexonly"
    case 'n':	 // 1 string to match.
      if (memcmp(Name.data()+1, "amespace", 8))
        break;
      return &Commands[48];	 // "namespace"
    case 'p':	 // 1 string to match.
      if (memcmp(Name.data()+1, "aragraph", 8))
        break;
      return &Commands[52];	 // "paragraph"
    case 'w':	 // 1 string to match.
      if (memcmp(Name.data()+1, "eakgroup", 8))
        break;
      return &Commands[86];	 // "weakgroup"
    }
    break;
  case 10:	 // 7 strings to match.
    switch (Name[0]) {
    default: break;
    case 'a':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ddtogroup", 9))
        break;
      return &Commands[1];	 // "addtogroup"
    case 'd':	 // 1 string to match.
      if (memcmp(Name.data()+1, "eprecated", 9))
        break;
      return &Commands[19];	 // "deprecated"
    case 'e':	 // 3 strings to match.
      if (memcmp(Name.data()+1, "nd", 2))
        break;
      switch (Name[3]) {
      default: break;
      case 'm':	 // 1 string to match.
        if (memcmp(Name.data()+4, "anonly", 6))
          break;
        return &Commands[43];	 // "endmanonly"
      case 'r':	 // 1 string to match.
        if (memcmp(Name.data()+4, "tfonly", 6))
          break;
        return &Commands[65];	 // "endrtfonly"
      case 'x':	 // 1 string to match.
        if (memcmp(Name.data()+4, "mlonly", 6))
          break;
        return &Commands[88];	 // "endxmlonly"
      }
      break;
    case 'h':	 // 1 string to match.
      if (memcmp(Name.data()+1, "eaderfile", 9))
        break;
      return &Commands[33];	 // "headerfile"
    case 's':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ubsection", 9))
        break;
      return &Commands[73];	 // "subsection"
    }
    break;
  case 11:	 // 2 strings to match.
    if (memcmp(Name.data()+0, "end", 3))
      break;
    switch (Name[3]) {
    default: break;
    case 'h':	 // 1 string to match.
      if (memcmp(Name.data()+4, "tmlonly", 7))
        break;
      return &Commands[35];	 // "endhtmlonly"
    case 'v':	 // 1 string to match.
      if (memcmp(Name.data()+4, "erbatim", 7))
        break;
      return &Commands[83];	 // "endverbatim"
    }
    break;
  case 12:	 // 1 string to match.
    if (memcmp(Name.data()+0, "endlatexonly", 12))
      break;
    return &Commands[40];	 // "endlatexonly"
  case 13:	 // 2 strings to match.
    switch (Name[0]) {
    default: break;
    case 's':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ubsubsection", 12))
        break;
      return &Commands[74];	 // "subsubsection"
    case 't':	 // 1 string to match.
      if (memcmp(Name.data()+1, "emplatefield", 12))
        break;
      return &Commands[76];	 // "templatefield"
    }
    break;
  }
  return NULL;
}

