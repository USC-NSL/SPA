#!/usr/bin/env python
# Copyright (c) 2012 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# This helps you preview the apps and extensions docs.
#
#    ./preview.py --help
#
# There are two modes: server- and render- mode. The default is server, in which
# a webserver is started on a port (default 8000). Navigating to paths on
# http://localhost:8000, for example
#
#     http://localhost:8000/extensions/tabs.html
#
# will render the documentation for the extension tabs API.
#
# On the other hand, render mode statically renders docs to stdout. Use this
# to save the output (more convenient than needing to save the page in a
# browser), handy when uploading the docs somewhere (e.g. for a review),
# and for profiling the server. For example,
#
#    ./preview.py -r extensions/tabs.html
#
# will output the documentation for the tabs API on stdout and exit immediately.
#
# Note: absolute paths into static content (e.g. /static/css/site.css) will be
# relative paths (e.g. static/css/site.css) for convenient sandboxing.

# NOTE: RUN THIS FIRST. Or all third_party imports will fail.
import build_server
# Copy all the files necessary to run the server. These are cleaned up when the
# server quits.
build_server.main()

from BaseHTTPServer import BaseHTTPRequestHandler, HTTPServer
from local_renderer import LocalRenderer
import logging
import optparse
import os
import sys
import time

def _GetLocalPath():
  if os.sep in sys.argv[0]:
    return os.path.join(sys.argv[0].rsplit(os.sep, 1)[0], os.pardir, os.pardir)
  return os.path.join(os.pardir, os.pardir)

def _Render(base_dir, path):
  renderer = LocalRenderer(base_dir)
  content, status, headers = renderer.Render(path, always_online=True)
  while status in [301, 302]:
    redirect = headers['Location'].lstrip('/')
    sys.stderr.write('<!-- Redirected %s to %s -->\n' % (path, redirect))
    content, status, headers = renderer.Render(redirect, always_online=True)
  return (content, status, headers)

class RequestHandler(BaseHTTPRequestHandler):
  class Factory(object):
    def __init__(self, base_dir):
      self._base_dir = base_dir

    def Create(self, *args):
      return RequestHandler(self._base_dir, *args)

  def __init__(self, base_dir, *args):
    self._base_dir = base_dir
    BaseHTTPRequestHandler.__init__(self, *args)

  """A HTTPRequestHandler that outputs the docs page generated by Handler.
  """
  def do_GET(self):
    content, status, headers = _Render(self._base_dir, self.path)
    self.send_response(status)
    for k, v in headers.iteritems():
      self.send_header(k, v)
    self.end_headers()
    self.wfile.write(content)

if __name__ == '__main__':
  parser = optparse.OptionParser(
      description='Runs a server to preview the extension documentation.',
      usage='usage: %prog [option]...')
  parser.add_option('-p', '--port', default='8000',
      help='port to run the server on')
  parser.add_option('-d', '--directory', default=_GetLocalPath(),
      help='extensions directory to serve from - '
           'should be chrome/common/extensions within a Chromium checkout')
  parser.add_option('-r', '--render', default='',
      help='statically render a page and print to stdout rather than starting '
           'the server, e.g. apps/storage.html. The path may optionally end '
           'with #n where n is the number of times to render the page before '
           'printing it, e.g. apps/storage.html#50, to use for profiling.')
  parser.add_option('-t', '--time', action='store_true',
      help='Print the time taken rendering rather than the result.')

  (opts, argv) = parser.parse_args()

  if (not os.path.isdir(opts.directory) or
      not os.path.isdir(os.path.join(opts.directory, 'docs')) or
      not os.path.isdir(os.path.join(opts.directory, 'api'))):
    print('Specified directory does not exist or does not contain extension '
          'docs.')
    exit()

  if opts.render:
    if opts.render.find('#') >= 0:
      (path, iterations) = opts.render.rsplit('#', 1)
      extra_iterations = int(iterations) - 1
    else:
      path = opts.render
      extra_iterations = 0

    if opts.time:
      start_time = time.time()

    content, status, headers = _Render(opts.directory, path)
    if status != 200:
      print('Error status: %s' % status)
      exit(1)

    for _ in range(extra_iterations):
      _Render(opts.directory, path)

    if opts.time:
      print('Took %s seconds' % (time.time() - start_time))
    else:
      # Static paths will show up as /stable/static/foo but this only makes
      # sense from a webserver.
      print(content.replace('/stable/static', 'static'))
    exit()

  print('Starting previewserver on port %s' % opts.port)
  print('')
  print('The extension documentation can be found at:')
  print('')
  print('  http://localhost:%s/extensions/' % opts.port)
  print('')
  print('The apps documentation can be found at:')
  print('')
  print('  http://localhost:%s/apps/' % opts.port)
  print('')

  logging.getLogger().setLevel(logging.INFO)
  server = HTTPServer(('', int(opts.port)),
                      RequestHandler.Factory(opts.directory).Create)
  try:
    server.serve_forever()
  finally:
    server.socket.close()
